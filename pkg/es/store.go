package es

import (
	"context"
	"errors"
	"time"
)

var ErrStreamConcurrentModification = errors.New("stream concurrent modification")
var ErrInvalidEvent = errors.New("invalid event")

type EventStore interface {
	// First event version should be the latest already published inside the stream event version+1
	PublishEvents(ctx context.Context, events ...*EventRecord) error
	GetStreamEvents(ctx context.Context, stream string) ([]*EventRecord, error)
	SubscribeOnEvents(ctx context.Context, filter EventFilter) (<-chan *EventRecord, func(), error)
}

// Full event info
// Stream = AggregateType + AggregateID
type EventRecord struct {
	Timestamp time.Time         // global sequence id, read only, generated by store
	Stream    string            // stream name, usually stream = the aggregate instance
	Sequence  uint32            // sequence inside stream, used for optimistic locking
	Type      string            // event type, got from data
	Data      interface{}       // business info
	Meta      map[string]string // non-business info
}

type EventFilter struct {
	Stream string    // default all streams
	Types  []string  // default all types
	FTE    bool      // default from the beginning
	FTT    time.Time // default from the beginning
	Back   bool      // default forward
}

func (ef *EventFilter) WithTheStream(stream string) *EventFilter {
	ef.Stream = stream
	return ef
}

func (ef *EventFilter) WithTypes(types ...string) *EventFilter {
	ef.Types = types
	return ef
}

func (ef *EventFilter) FromTheEnd() *EventFilter {
	ef.FTE = true
	return ef
}

func (ef *EventFilter) FromTheTimestamp(timestamp time.Time) *EventFilter {
	ef.FTT = timestamp
	return ef
}

func (ef *EventFilter) Backward() *EventFilter {
	ef.Back = true
	return ef
}
