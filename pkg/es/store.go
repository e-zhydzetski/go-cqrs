package es

import (
	"context"
	"errors"
	"time"
)

var ErrStreamConcurrentModification = errors.New("stream concurrent modification")
var ErrInvalidEvent = errors.New("invalid event")

type EventStore interface {
	// First event version should be the latest already published inside the stream event version+1
	PublishEvents(ctx context.Context, events ...*EventRecord) (StorePosition, error)
	GetStreamEvents(ctx context.Context, stream string) ([]*EventRecord, error)
	SubscribeOnEvents(ctx context.Context, filter *EventFilter, callbackFunc func(event *EventRecord) bool) error
}

// Full event info
// Stream = AggregateType + AggregateID
type EventRecord struct {
	GlobalSequence StorePosition     // global sequence inside the event store, read only, generated by store
	Timestamp      time.Time         // timestamp from global sequence, read only, generated by store
	Stream         string            // stream name, usually stream = the aggregate instance
	Sequence       uint32            // sequence inside stream, used for optimistic locking
	Type           string            // event type, got from data
	Data           interface{}       // business info
	Meta           map[string]string // non-business info
}

type StorePosition uint64

const (
	StorePosBegin StorePosition = 0          // min uint64
	StorePosEnd                 = ^uint64(0) // max uint64
)

// TODO add limit
type EventFilter struct {
	Stream string
	Pos    StorePosition
	//Back   bool
}

func FilterDefault() *EventFilter {
	return &EventFilter{
		Stream: "",            // default all streams
		Pos:    StorePosBegin, // default from the beginning
		//Back:   false,         // default forward
	}
}

func (ef *EventFilter) WithTheStream(stream string) *EventFilter {
	ef.Stream = stream
	return ef
}

func (ef *EventFilter) FromThePosition(pos StorePosition) *EventFilter {
	ef.Pos = pos
	return ef
}

//func (ef *EventFilter) Backward() *EventFilter {
//	ef.Back = true
//	return ef
//}
